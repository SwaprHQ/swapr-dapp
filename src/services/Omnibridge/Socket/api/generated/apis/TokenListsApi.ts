/* tslint:disable */
/* eslint-disable */
/**
 * Movr Aggregator API
 * The Movr Aggregator API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    TokenListOutputDTO,
    TokenListOutputDTOFromJSON,
    TokenListOutputDTOToJSON,
} from '../models';

export interface TokenListControllerGetToTokenListRequest {
    fromChainId: string;
    toChainId: string;
    disableSwapping?: boolean;
    includeDexes?: TokenListControllerGetToTokenListIncludeDexesEnum;
    excludeDexes?: TokenListControllerGetToTokenListExcludeDexesEnum;
    includeBridges?: Array<TokenListControllerGetToTokenListIncludeBridgesEnum>;
    excludeBridges?: Array<TokenListControllerGetToTokenListExcludeBridgesEnum>;
    singleTxOnly?: boolean;
    aPIKEY?: string;
}

export interface TokenListControllerGetfromTokenListRequest {
    fromChainId: string;
    toChainId: string;
    disableSwapping?: boolean;
    includeDexes?: TokenListControllerGetfromTokenListIncludeDexesEnum;
    excludeDexes?: TokenListControllerGetfromTokenListExcludeDexesEnum;
    includeBridges?: Array<TokenListControllerGetfromTokenListIncludeBridgesEnum>;
    excludeBridges?: Array<TokenListControllerGetfromTokenListExcludeBridgesEnum>;
    singleTxOnly?: boolean;
    aPIKEY?: string;
}

/**
 * 
 */
export class TokenListsApi extends runtime.BaseAPI {

    /**
     */
    async tokenListControllerGetToTokenListRaw(requestParameters: TokenListControllerGetToTokenListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TokenListOutputDTO>> {
        if (requestParameters.fromChainId === null || requestParameters.fromChainId === undefined) {
            throw new runtime.RequiredError('fromChainId','Required parameter requestParameters.fromChainId was null or undefined when calling tokenListControllerGetToTokenList.');
        }

        if (requestParameters.toChainId === null || requestParameters.toChainId === undefined) {
            throw new runtime.RequiredError('toChainId','Required parameter requestParameters.toChainId was null or undefined when calling tokenListControllerGetToTokenList.');
        }

        const queryParameters: any = {};

        if (requestParameters.fromChainId !== undefined) {
            queryParameters['fromChainId'] = requestParameters.fromChainId;
        }

        if (requestParameters.toChainId !== undefined) {
            queryParameters['toChainId'] = requestParameters.toChainId;
        }

        if (requestParameters.disableSwapping !== undefined) {
            queryParameters['disableSwapping'] = requestParameters.disableSwapping;
        }

        if (requestParameters.includeDexes !== undefined) {
            queryParameters['includeDexes'] = requestParameters.includeDexes;
        }

        if (requestParameters.excludeDexes !== undefined) {
            queryParameters['excludeDexes'] = requestParameters.excludeDexes;
        }

        if (requestParameters.includeBridges) {
            queryParameters['includeBridges'] = requestParameters.includeBridges;
        }

        if (requestParameters.excludeBridges) {
            queryParameters['excludeBridges'] = requestParameters.excludeBridges;
        }

        if (requestParameters.singleTxOnly !== undefined) {
            queryParameters['singleTxOnly'] = requestParameters.singleTxOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
            headerParameters['API-KEY'] = String(requestParameters.aPIKEY);
        }

        const response = await this.request({
            path: `/v2/token-lists/to-token-list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenListOutputDTOFromJSON(jsonValue));
    }

    /**
     */
    async tokenListControllerGetToTokenList(requestParameters: TokenListControllerGetToTokenListRequest, initOverrides?: RequestInit): Promise<TokenListOutputDTO> {
        const response = await this.tokenListControllerGetToTokenListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async tokenListControllerGetfromTokenListRaw(requestParameters: TokenListControllerGetfromTokenListRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TokenListOutputDTO>> {
        if (requestParameters.fromChainId === null || requestParameters.fromChainId === undefined) {
            throw new runtime.RequiredError('fromChainId','Required parameter requestParameters.fromChainId was null or undefined when calling tokenListControllerGetfromTokenList.');
        }

        if (requestParameters.toChainId === null || requestParameters.toChainId === undefined) {
            throw new runtime.RequiredError('toChainId','Required parameter requestParameters.toChainId was null or undefined when calling tokenListControllerGetfromTokenList.');
        }

        const queryParameters: any = {};

        if (requestParameters.fromChainId !== undefined) {
            queryParameters['fromChainId'] = requestParameters.fromChainId;
        }

        if (requestParameters.toChainId !== undefined) {
            queryParameters['toChainId'] = requestParameters.toChainId;
        }

        if (requestParameters.disableSwapping !== undefined) {
            queryParameters['disableSwapping'] = requestParameters.disableSwapping;
        }

        if (requestParameters.includeDexes !== undefined) {
            queryParameters['includeDexes'] = requestParameters.includeDexes;
        }

        if (requestParameters.excludeDexes !== undefined) {
            queryParameters['excludeDexes'] = requestParameters.excludeDexes;
        }

        if (requestParameters.includeBridges) {
            queryParameters['includeBridges'] = requestParameters.includeBridges;
        }

        if (requestParameters.excludeBridges) {
            queryParameters['excludeBridges'] = requestParameters.excludeBridges;
        }

        if (requestParameters.singleTxOnly !== undefined) {
            queryParameters['singleTxOnly'] = requestParameters.singleTxOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
            headerParameters['API-KEY'] = String(requestParameters.aPIKEY);
        }

        const response = await this.request({
            path: `/v2/token-lists/from-token-list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenListOutputDTOFromJSON(jsonValue));
    }

    /**
     */
    async tokenListControllerGetfromTokenList(requestParameters: TokenListControllerGetfromTokenListRequest, initOverrides?: RequestInit): Promise<TokenListOutputDTO> {
        const response = await this.tokenListControllerGetfromTokenListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetToTokenListIncludeDexesEnum {
    Oneinch = 'oneinch'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetToTokenListExcludeDexesEnum {
    Oneinch = 'oneinch'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetToTokenListIncludeBridgesEnum {
    PolygonBridge = 'polygon-bridge',
    Hop = 'hop',
    AnyswapRouterV4 = 'anyswap-router-v4',
    Hyphen = 'hyphen',
    ArbitrumBridge = 'arbitrum-bridge',
    Connext = 'connext'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetToTokenListExcludeBridgesEnum {
    PolygonBridge = 'polygon-bridge',
    Hop = 'hop',
    AnyswapRouterV4 = 'anyswap-router-v4',
    Hyphen = 'hyphen',
    ArbitrumBridge = 'arbitrum-bridge',
    Connext = 'connext'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetfromTokenListIncludeDexesEnum {
    Oneinch = 'oneinch'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetfromTokenListExcludeDexesEnum {
    Oneinch = 'oneinch'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetfromTokenListIncludeBridgesEnum {
    PolygonBridge = 'polygon-bridge',
    Hop = 'hop',
    AnyswapRouterV4 = 'anyswap-router-v4',
    Hyphen = 'hyphen',
    ArbitrumBridge = 'arbitrum-bridge',
    Connext = 'connext'
}
/**
    * @export
    * @enum {string}
    */
export enum TokenListControllerGetfromTokenListExcludeBridgesEnum {
    PolygonBridge = 'polygon-bridge',
    Hop = 'hop',
    AnyswapRouterV4 = 'anyswap-router-v4',
    Hyphen = 'hyphen',
    ArbitrumBridge = 'arbitrum-bridge',
    Connext = 'connext'
}
